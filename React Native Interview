React Native Performance & Architecture1. Preventing Unnecessary Re-renders in a Large FlatListOptimizing a large FlatList is critical for maintaining 60fps on lower-end devices. Here are the core strategies to prevent re-renders and frame drops:A. Memoize the renderItem ComponentThe most common performance killer is the renderItem component re-rendering whenever the parent updates, even if the item's data hasn't changed.Solution: Wrap the list item component in React.memo.Deep Comparison: If the props are complex objects, consider using a custom comparison function (second argument of React.memo) or ensuring the data structure remains stable (normalized state).B. Stable References for Props (Callbacks)Passing anonymous functions directly into props causes re-renders because a new function is created on every render cycle.Bad: renderItem={({ item }) => <Item onPress={() => handlePress(item.id)} />}Good: Define the renderItem function outside the component or memoize it using useCallback. Similarly, the onPress handler inside the item should be optimized so it doesn't break React.memo (e.g., by passing the ID to a parent handler rather than creating a closure).C. keyExtractorAlways provide a unique, string-based key via keyExtractor. React uses this to track item identity. Using index as a key is detrimental if the list order changes or items are deleted.D. getItemLayoutIf all your list items have the same height (or a predictable height), implementing getItemLayout is a massive optimization. It allows React Native to calculate the position of items without waiting for the layout pass (dynamic measurement), allowing it to skip rendering items that are off-screen much faster.E. Configuration PropsinitialNumToRender: Set this to the exact number of items required to fill the screen on the first load. Too high renders unnecessary items; too low causes blank spots.maxToRenderPerBatch: Controls how many items render per batch. Lower numbers improve UI responsiveness but might result in blank areas during fast scrolls.windowSize: Determines how many "screens" worth of content are kept in memory (default is 21). Reducing this (e.g., to 5 or 10) saves memory but increases the chance of seeing blank space when scrolling back up.2. The "Bridge" in React NativeWhat is it?The "Bridge" (in the legacy architecture) is the communication bus that connects the JavaScript Thread (where your React logic runs) and the Native/Main Thread (where UI rendering and native APIs live).Since these two worlds cannot talk to each other directly, they communicate by sending asynchronous, serialized JSON messages across this Bridge.Why does it matter for performance?The Bridge is inherently asynchronous and relies on serialization (stringifying data to JSON) and deserialization (parsing JSON).Serialization Overhead: Converting large objects (like a massive list of data) into JSON strings is CPU-intensive.Congestion: The Bridge can get "clogged." If you try to send too many messages too quickly (e.g., tracking a scroll event every millisecond, or complex animations driven by JS), the Bridge queue backs up. The Native thread waits for the JS thread to catch up, leading to dropped frames and "stuttery" UI.Asynchronous Nature: You cannot synchronously access a native value. For example, measuring a view's width requires sending a message, waiting, and getting a callback, which complicates synchronous UI logic.Note: The New Architecture (Fabric and TurboModules) replaces the Bridge with JSI (JavaScript Interface), allowing JavaScript to hold references to C++ Host Objects and invoke methods on them synchronously, eliminating the serialization overhead.